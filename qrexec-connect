#!/usr/bin/python

import sys
import os
import signal
import functools
import logging
import asyncio
import socket
import subprocess
import systemd.journal
import systemd.daemon
import argparse
import qrexec.client
import shlex


class QrexecConnect:
    exit_signals = ("SIGINT", "SIGTERM")

    NO_LISTEN_FDS = 125
    UNSUPPORTED_ADDRESS_FAMILY = 126
    FILEDESCRIPTORNAME_ERROR = 127

    def __init__(self):
        arg_parser = argparse.ArgumentParser(
            description="%(prog)s: systemd-native qrexec-client-vm",
        )
        arg_parser.add_argument("--buffer-size", type=int, default=65536)
        arg_parser.add_argument("-d", "--debug", action="store_true")

        self.logger = logging.getLogger(arg_parser.prog)
        self.logger.addHandler(
            systemd.journal.JournalHandler(SYSLOG_IDENTIFIER=arg_parser.prog)
        )

        args = arg_parser.parse_args()
        self.buffer_size = args.buffer_size
        self.debug = args.debug

        if self.debug:
            self.logger.setLevel(logging.DEBUG)
        else:
            self.logger.setLevel(logging.INFO)

        self.fds_with_names = systemd.daemon.listen_fds_with_names()

        if not self.fds_with_names:
            print("No listen FDs found", file=sys.stderr)
            exit(self.NO_LISTEN_FDS)

    def exit(self, signame, loop):
        systemd.daemon.notify("STOPPING=1")
        loop.stop
        exit(0)

    async def run(self):
        loop = asyncio.get_running_loop()

        for signame in self.exit_signals:
            qrexec_connect_exit = functools.partial(self.exit, signame, loop)

            loop.add_signal_handler(
                getattr(signal, signame),
                qrexec_connect_exit,
            )

        self.logger.info("Starting connection servers")

        connection_servers = (
            self.make_connection_server(fd, fd_name)
            for fd, fd_name in self.fds_with_names.items()
        )

        systemd.daemon.notify("READY=1")

        await asyncio.gather(*connection_servers)

    def make_connection_server(self, fd, fd_name):
        sock = socket.socket(fileno=fd)

        argv = shlex.split(fd_name)

        if len(argv) != 2:
            print(
                f'{sock.getsockname()}: FileDescriptorName takes 2 arguments but {len(argv)} {"was" if len(argv) == 1 else "were"} given',
                file=sys.stderr,
            )
            exit(self.FILEDESCRIPTORNAME_ERROR)

        return self.serve_connection(sock, argv[0], argv[1])

    async def serve_connection(self, sock, target_qube, rpc_service):
        rpc_service_components = rpc_service.split("+", maxsplit=1)

        rpc_name = rpc_service_components[0]

        if len(rpc_service_components) == 2:
            rpc_arg = rpc_service_components[1]
        else:
            rpc_arg = None

        # functools.partial can't generate async functions, yet
        async def handle_connection(reader, writer):
            await self.qrexec_handle_connection(
                target_qube, rpc_name, rpc_arg, reader, writer
            )

        if sock.family in (socket.AF_INET, socket.AF_INET6):
            server = await asyncio.start_server(handle_connection, sock=sock)
        elif sock.family == socket.AF_UNIX:
            server = await asyncio.start_unix_server(handle_connection, sock=sock)
        else:
            print(f"Unsupported address family: {sock.family}", file=sys.stderr)
            exit(self.UNSUPPORTED_ADDRESS_FAMILY)

        self.logger.info(
            f"{sock.getsockname()}: {shlex.join((target_qube, rpc_service))}"
        )

        async with server:
            await server.serve_forever()

    async def qrexec_handle_connection(
        self, target_qube, rpc_name, rpc_arg, reader, writer
    ):
        command = qrexec.client.make_command(target_qube, rpc_name, rpc_arg)

        qrexec_client = await asyncio.create_subprocess_exec(
            *command,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )

        async with asyncio.TaskGroup() as task_group:
            task_group.create_task(qrexec_client.wait())
            task_group.create_task(self.qrexec_pipe(reader, qrexec_client.stdin))
            task_group.create_task(self.qrexec_pipe(qrexec_client.stdout, writer))

        if qrexec_client.returncode != 0:
            if rpc_arg:
                rpc_service = "+".join((rcp_name, rpc_arg))
            else:
                rpc_service = rpc_name

            stderr = await qrexec_client.stderr.read(self.buffer_size)
            error_message = stderr.decode("utf-8")

            fd_name = shlex.join((target_qube, rpc_service))
            self.logger.warning(f"{fd_name}: {error_message}")

    async def qrexec_pipe(self, source, sink):
        while not source.at_eof():
            data = await source.read(self.buffer_size)
            if data:
                sink.write(data)
                await sink.drain()
            else:
                source.feed_eof()

        sink.close()
        await sink.wait_closed()


if __name__ == "__main__":
    asyncio.run(QrexecConnect().run())
